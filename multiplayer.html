<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="theme-color" content="#667eea">
    <title>Multiplayer Snake Game</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            color: white;
            padding: 20px;
        }

        .container {
            text-align: center;
            background: rgba(255, 255, 255, 0.1);
            padding: 30px;
            border-radius: 20px;
            backdrop-filter: blur(10px);
            box-shadow: 0 8px 32px 0 rgba(31, 38, 135, 0.37);
            max-width: 95vw;
        }

        h1 {
            margin-bottom: 20px;
            font-size: 2.5em;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.3);
        }

        .game-info {
            display: flex;
            justify-content: space-around;
            margin-bottom: 20px;
            font-size: 1.2em;
            font-weight: 600;
            flex-wrap: wrap;
            gap: 10px;
        }

        .info-box {
            background: rgba(255, 255, 255, 0.2);
            padding: 10px 20px;
            border-radius: 10px;
            min-width: 120px;
        }

        canvas {
            background: #1a1a2e;
            border: 4px solid white;
            border-radius: 10px;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.3);
            display: block;
            margin: 0 auto;
            max-width: 100%;
            height: auto;
        }

        .players-list {
            margin-top: 20px;
            background: rgba(255, 255, 255, 0.1);
            padding: 15px;
            border-radius: 10px;
            max-height: 200px;
            overflow-y: auto;
        }

        .player-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 8px;
            margin: 5px 0;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 5px;
        }

        .player-color {
            width: 20px;
            height: 20px;
            border-radius: 50%;
            display: inline-block;
            margin-right: 10px;
        }

        .player-status {
            font-size: 0.8em;
            opacity: 0.8;
        }

        .instructions {
            margin-top: 20px;
            font-size: 0.9em;
            opacity: 0.9;
            line-height: 1.6;
        }

        .game-over {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 0, 0, 0.95);
            padding: 40px;
            border-radius: 20px;
            text-align: center;
            display: none;
            z-index: 10;
            min-width: 300px;
        }

        .game-over.show {
            display: block;
        }

        .game-over h2 {
            font-size: 2.5em;
            margin-bottom: 20px;
            color: #ff6b6b;
        }

        .game-over p {
            font-size: 1.3em;
            margin-bottom: 20px;
        }

        button {
            background: rgba(255, 255, 255, 0.2);
            border: 2px solid white;
            color: white;
            padding: 12px 24px;
            font-size: 1em;
            border-radius: 10px;
            cursor: pointer;
            font-weight: 600;
            transition: all 0.3s ease;
        }

        button:hover {
            background: rgba(255, 255, 255, 0.3);
            transform: translateY(-2px);
        }

        .connection-status {
            padding: 8px 16px;
            border-radius: 20px;
            font-size: 0.9em;
            display: inline-block;
            margin-bottom: 10px;
        }

        .connection-status.connected {
            background: #2ecc71;
        }

        .connection-status.disconnected {
            background: #e74c3c;
        }

        /* Skin Selection Styles */
        .skin-selection {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.9);
            display: none;
            justify-content: center;
            align-items: center;
            z-index: 1000;
        }

        .skin-selection.show {
            display: flex;
        }

        .skin-modal {
            background: rgba(255, 255, 255, 0.1);
            padding: 30px;
            border-radius: 20px;
            backdrop-filter: blur(10px);
            box-shadow: 0 8px 32px 0 rgba(31, 38, 135, 0.37);
            max-width: 90vw;
            max-height: 90vh;
            overflow-y: auto;
        }

        .skin-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
            gap: 20px;
            margin: 20px 0;
        }

        .skin-option {
            background: rgba(255, 255, 255, 0.1);
            border: 2px solid transparent;
            border-radius: 15px;
            padding: 15px;
            cursor: pointer;
            transition: all 0.3s ease;
            text-align: center;
        }

        .skin-option:hover {
            background: rgba(255, 255, 255, 0.2);
            transform: translateY(-2px);
        }

        .skin-option.selected {
            border-color: #4ecca3;
            background: rgba(78, 204, 163, 0.2);
        }

        .skin-preview {
            width: 60px;
            height: 60px;
            margin: 0 auto 10px;
            border-radius: 10px;
            position: relative;
            overflow: hidden;
        }

        .skin-name {
            font-weight: 600;
            margin-bottom: 5px;
        }

        .skin-description {
            font-size: 0.8em;
            opacity: 0.8;
        }

        /* Mobile Controls */
        .mobile-controls {
            display: none;
            margin-top: 20px;
            position: relative;
        }

        .dpad-container {
            width: 200px;
            height: 200px;
            position: relative;
            margin: 0 auto;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 50%;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.3);
        }

        .dpad-button {
            position: absolute;
            width: 60px;
            height: 60px;
            background: rgba(255, 255, 255, 0.3);
            border: 2px solid white;
            border-radius: 10px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 24px;
            cursor: pointer;
            user-select: none;
            touch-action: none;
            transition: all 0.1s;
        }

        .dpad-button:active {
            background: rgba(255, 255, 255, 0.6);
            transform: scale(0.95);
        }

        .dpad-center {
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 50px;
            height: 50px;
            background: rgba(255, 255, 255, 0.2);
            border-radius: 50%;
            font-size: 18px;
        }

        .dpad-up {
            top: 5px;
            left: 50%;
            transform: translateX(-50%);
        }

        .dpad-down {
            bottom: 5px;
            left: 50%;
            transform: translateX(-50%);
        }

        .dpad-left {
            left: 5px;
            top: 50%;
            transform: translateY(-50%);
        }

        .dpad-right {
            right: 5px;
            top: 50%;
            transform: translateY(-50%);
        }

        .dpad-upleft {
            top: 20px;
            left: 20px;
            width: 50px;
            height: 50px;
            font-size: 20px;
        }

        .dpad-upright {
            top: 20px;
            right: 20px;
            width: 50px;
            height: 50px;
            font-size: 20px;
        }

        .dpad-downleft {
            bottom: 20px;
            left: 20px;
            width: 50px;
            height: 50px;
            font-size: 20px;
        }

        .dpad-downright {
            bottom: 20px;
            right: 20px;
            width: 50px;
            height: 50px;
            font-size: 20px;
        }

        @media (max-width: 1000px) {
            canvas {
                max-width: 95vw;
                max-height: 95vw;
            }

            h1 {
                font-size: 1.8em;
            }

            .container {
                padding: 15px;
            }

            .mobile-controls {
                display: block;
            }

            .instructions {
                display: none;
            }

            .players-list {
                max-height: 150px;
            }
        }

        @media (max-width: 600px) {
            h1 {
                font-size: 1.4em;
            }

            .game-info {
                font-size: 1em;
            }

            .info-box {
                min-width: 100px;
                padding: 8px 12px;
            }

            .dpad-container {
                width: 180px;
                height: 180px;
            }

            .dpad-button {
                width: 55px;
                height: 55px;
                font-size: 20px;
            }

            .dpad-center {
                width: 45px;
                height: 45px;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>üêç Multiplayer Snake Game</h1>
        
        <div class="connection-status disconnected" id="connectionStatus">
            ‚ö†Ô∏è Connecting...
        </div>

        <div class="game-info">
            <div class="info-box">
                <div>Your Score: <span id="myScore">0</span></div>
            </div>
            <div class="info-box">
                <div>Players: <span id="playerCount">0</span></div>
            </div>
            <div class="info-box">
                <div>Your Color: <span id="myColor">-</span></div>
            </div>
            <div class="info-box">
                <button id="skinBtn" style="background: rgba(255, 255, 255, 0.2); border: 2px solid white; color: white; padding: 8px 16px; border-radius: 8px; cursor: pointer; font-size: 0.9em;">üé® Skin</button>
            </div>
        </div>

        <canvas id="gameCanvas" width="900" height="900"></canvas>

        <div class="players-list">
            <h3>üèÜ Leaderboard</h3>
            <div id="playersList"></div>
        </div>

        <div class="instructions">
            <p>üéÆ Use Arrow Keys or WASD to control the snake</p>
            <p>‚ÜóÔ∏è Use Q/E/Z/C for diagonal movement</p>
            <p>üçé Eat red food (+10 pts) to grow</p>
            <p>‚≠ê Eat golden star (+50 pts) for INVINCIBILITY!</p>
            <p>üõ°Ô∏è Power-up: RED blinking, pass through walls & snakes, 10 seconds</p>
            <p>‚ö†Ô∏è Avoid other players and walls (unless invincible)!</p>
        </div>

        <div class="mobile-controls">
            <div class="dpad-container">
                <div class="dpad-button dpad-center">‚è∏Ô∏è</div>
                <div class="dpad-button dpad-up" data-direction="up">‚¨ÜÔ∏è</div>
                <div class="dpad-button dpad-down" data-direction="down">‚¨áÔ∏è</div>
                <div class="dpad-button dpad-left" data-direction="left">‚¨ÖÔ∏è</div>
                <div class="dpad-button dpad-right" data-direction="right">‚û°Ô∏è</div>
                <div class="dpad-button dpad-upleft" data-direction="upleft">‚ÜñÔ∏è</div>
                <div class="dpad-button dpad-upright" data-direction="upright">‚ÜóÔ∏è</div>
                <div class="dpad-button dpad-downleft" data-direction="downleft">‚ÜôÔ∏è</div>
                <div class="dpad-button dpad-downright" data-direction="downright">‚ÜòÔ∏è</div>
            </div>
            <p style="margin-top: 15px; font-size: 0.9em; opacity: 0.9;">
                üì± Use the D-pad to control your snake
            </p>
        </div>
    </div>

    <div class="game-over" id="gameOver">
        <h2>You Died!</h2>
        <p>Final Score: <span id="finalScore">0</span></p>
        <button onclick="location.reload()">Play Again</button>
    </div>

    <!-- Skin Selection Modal -->
    <div class="skin-selection" id="skinSelection">
        <div class="skin-modal">
            <h2>üé® Choose Your Snake Skin</h2>
            <div class="skin-grid" id="skinGrid">
                <!-- Skin options will be populated by JavaScript -->
            </div>
            <div style="text-align: center; margin-top: 20px;">
                <button onclick="closeSkinSelection()" style="margin-right: 10px;">Cancel</button>
                <button onclick="applySkin()" id="applySkinBtn" disabled>Apply Skin</button>
            </div>
        </div>
    </div>

    <script src="/socket.io/socket.io.js"></script>
    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const myScoreElement = document.getElementById('myScore');
        const playerCountElement = document.getElementById('playerCount');
        const myColorElement = document.getElementById('myColor');
        const playersListElement = document.getElementById('playersList');
        const finalScoreElement = document.getElementById('finalScore');
        const gameOverElement = document.getElementById('gameOver');
        const connectionStatusElement = document.getElementById('connectionStatus');

        let socket = io();
        let myPlayerId = null;
        let players = {};
        let food = null;
        let specialFood = null;
        let tileCount = 30;
        let gridSize = 30;
        let blinkState = {};

        // Snake Skins
        const snakeSkins = {
            classic: {
                name: 'Classic Green',
                description: 'The original snake look',
                bodyColor: '#4ecca3',
                headColor: '#45b393',
                powerUpBodyColor: '#ff3333',
                powerUpHeadColor: '#ff0000',
                pattern: 'solid'
            },
            fire: {
                name: 'Fire Snake',
                description: 'Hot and dangerous',
                bodyColor: '#ff6b35',
                headColor: '#ff4500',
                powerUpBodyColor: '#ff3333',
                powerUpHeadColor: '#ff0000',
                pattern: 'gradient'
            },
            ice: {
                name: 'Ice Snake',
                description: 'Cool and slippery',
                bodyColor: '#87ceeb',
                headColor: '#4682b4',
                powerUpBodyColor: '#ff3333',
                powerUpHeadColor: '#ff0000',
                pattern: 'solid'
            },
            rainbow: {
                name: 'Rainbow Snake',
                description: 'Colorful and vibrant',
                bodyColor: '#ff69b4',
                headColor: '#9370db',
                powerUpBodyColor: '#ff3333',
                powerUpHeadColor: '#ff0000',
                pattern: 'rainbow'
            },
            neon: {
                name: 'Neon Snake',
                description: 'Glowing in the dark',
                bodyColor: '#00ff41',
                headColor: '#00cc33',
                powerUpBodyColor: '#ff3333',
                powerUpHeadColor: '#ff0000',
                pattern: 'neon'
            },
            gold: {
                name: 'Golden Snake',
                description: 'Luxurious and shiny',
                bodyColor: '#ffd700',
                headColor: '#ffb347',
                powerUpBodyColor: '#ff3333',
                powerUpHeadColor: '#ff0000',
                pattern: 'metallic'
            },
            dark: {
                name: 'Shadow Snake',
                description: 'Dark and mysterious',
                bodyColor: '#2c2c54',
                headColor: '#40407a',
                powerUpBodyColor: '#ff3333',
                powerUpHeadColor: '#ff0000',
                pattern: 'solid'
            },
            ocean: {
                name: 'Ocean Snake',
                description: 'Deep blue like the sea',
                bodyColor: '#006994',
                headColor: '#004d6b',
                powerUpBodyColor: '#ff3333',
                powerUpHeadColor: '#ff0000',
                pattern: 'waves'
            }
        };

        // Current skin
        let currentSkin = 'classic';
        let selectedSkin = 'classic';

        // Colors
        const foodColor = '#ff6b6b';
        const specialFoodColor = '#ffd700';
        const gridColor = '#2a2a3e';
        const powerUpColor = '#ff3333';
        const powerUpLightColor = '#ff6666';

        // Initialize blink intervals for players
        setInterval(() => {
            for (let playerId in players) {
                if (players[playerId].powerUpActive) {
                    blinkState[playerId] = !blinkState[playerId];
                } else {
                    blinkState[playerId] = false;
                }
            }
        }, 150);

        // Socket events
        socket.on('connect', () => {
            connectionStatusElement.textContent = '‚úÖ Connected';
            connectionStatusElement.className = 'connection-status connected';
        });

        socket.on('disconnect', () => {
            connectionStatusElement.textContent = '‚ö†Ô∏è Disconnected';
            connectionStatusElement.className = 'connection-status disconnected';
        });

        socket.on('init', (data) => {
            myPlayerId = data.playerId;
            players = data.players;
            food = data.food;
            specialFood = data.specialFood;
            tileCount = data.tileCount;
            gridSize = data.gridSize;
            
            // Set canvas size based on screen size
            const maxSize = Math.min(window.innerWidth * 0.95, 900);
            canvas.width = tileCount * gridSize;
            canvas.height = tileCount * gridSize;
            
            // Scale canvas for mobile
            if (window.innerWidth < 1000) {
                canvas.style.width = maxSize + 'px';
                canvas.style.height = maxSize + 'px';
            }
            
            myColorElement.textContent = players[myPlayerId].color.name;
            updateUI();
            drawGame();
        });

        socket.on('gameState', (data) => {
            players = data.players;
            food = data.food;
            specialFood = data.specialFood;
            updateUI();
            drawGame();
        });

        socket.on('playerJoined', (data) => {
            players[data.playerId] = data.player;
            updateUI();
        });

        socket.on('playerLeft', (playerId) => {
            delete players[playerId];
            updateUI();
        });

        socket.on('foodEaten', (data) => {
            food = data.newFood;
        });

        socket.on('specialFoodEaten', (data) => {
            specialFood = null;
        });

        socket.on('specialFoodSpawned', (data) => {
            specialFood = data;
        });

        socket.on('specialFoodExpired', () => {
            specialFood = null;
        });

        socket.on('playerDied', (data) => {
            if (data.playerId === myPlayerId) {
                finalScoreElement.textContent = data.score;
                gameOverElement.classList.add('show');
            }
        });

        socket.on('playerSkinChanged', (data) => {
            if (players[data.playerId]) {
                players[data.playerId].skin = data.skin;
                players[data.playerId].skinData = data.skinData;
                players[data.playerId].color = {
                    normal: data.skinData.bodyColor,
                    head: data.skinData.headColor,
                    name: data.skinData.name
                };
            }
        });

        // Handle direction change
        function changeDirection(direction) {
            if (!myPlayerId || !players[myPlayerId] || !players[myPlayerId].alive) return;

            const currentDirection = players[myPlayerId].direction;
            let newDirection = { dx: currentDirection.dx, dy: currentDirection.dy };

            const oppositeDirection = (newDx, newDy) => {
                return (currentDirection.dx === -newDx && currentDirection.dy === -newDy && 
                        currentDirection.dx !== 0 && currentDirection.dy !== 0);
            };

            switch (direction) {
                case 'up':
                    if (currentDirection.dy !== 1 || currentDirection.dx !== 0) {
                        newDirection = { dx: 0, dy: -1 };
                    }
                    break;
                case 'down':
                    if (currentDirection.dy !== -1 || currentDirection.dx !== 0) {
                        newDirection = { dx: 0, dy: 1 };
                    }
                    break;
                case 'left':
                    if (currentDirection.dx !== 1 || currentDirection.dy !== 0) {
                        newDirection = { dx: -1, dy: 0 };
                    }
                    break;
                case 'right':
                    if (currentDirection.dx !== -1 || currentDirection.dy !== 0) {
                        newDirection = { dx: 1, dy: 0 };
                    }
                    break;
                case 'upleft':
                    if (!oppositeDirection(-1, -1)) {
                        newDirection = { dx: -1, dy: -1 };
                    }
                    break;
                case 'upright':
                    if (!oppositeDirection(1, -1)) {
                        newDirection = { dx: 1, dy: -1 };
                    }
                    break;
                case 'downleft':
                    if (!oppositeDirection(-1, 1)) {
                        newDirection = { dx: -1, dy: 1 };
                    }
                    break;
                case 'downright':
                    if (!oppositeDirection(1, 1)) {
                        newDirection = { dx: 1, dy: 1 };
                    }
                    break;
            }

            socket.emit('changeDirection', newDirection);
        }

        // Keyboard controls
        document.addEventListener('keydown', (e) => {
            if (['ArrowUp', 'ArrowDown', 'ArrowLeft', 'ArrowRight', 'w', 'a', 's', 'd', 'q', 'e', 'z', 'c'].includes(e.key)) {
                e.preventDefault();
            }

            switch (e.key) {
                case 'ArrowUp':
                case 'w':
                case 'W':
                    changeDirection('up');
                    break;
                case 'ArrowDown':
                case 's':
                case 'S':
                    changeDirection('down');
                    break;
                case 'ArrowLeft':
                case 'a':
                case 'A':
                    changeDirection('left');
                    break;
                case 'ArrowRight':
                case 'd':
                case 'D':
                    changeDirection('right');
                    break;
                case 'q':
                case 'Q':
                    changeDirection('upleft');
                    break;
                case 'e':
                case 'E':
                    changeDirection('upright');
                    break;
                case 'z':
                case 'Z':
                    changeDirection('downleft');
                    break;
                case 'c':
                case 'C':
                    changeDirection('downright');
                    break;
            }
        });

        // Touch controls for mobile
        document.querySelectorAll('.dpad-button[data-direction]').forEach(button => {
            // Handle touch events
            button.addEventListener('touchstart', (e) => {
                e.preventDefault();
                const direction = button.getAttribute('data-direction');
                changeDirection(direction);
            });

            // Handle click events (for desktop testing)
            button.addEventListener('click', (e) => {
                e.preventDefault();
                const direction = button.getAttribute('data-direction');
                changeDirection(direction);
            });
        });

        // Prevent scrolling on mobile when touching the game area
        document.addEventListener('touchmove', (e) => {
            if (e.target.closest('.dpad-container') || e.target.closest('canvas')) {
                e.preventDefault();
            }
        }, { passive: false });

        // Swipe gesture support on canvas
        let touchStartX = 0;
        let touchStartY = 0;
        let touchEndX = 0;
        let touchEndY = 0;

        canvas.addEventListener('touchstart', (e) => {
            touchStartX = e.changedTouches[0].screenX;
            touchStartY = e.changedTouches[0].screenY;
        });

        canvas.addEventListener('touchend', (e) => {
            touchEndX = e.changedTouches[0].screenX;
            touchEndY = e.changedTouches[0].screenY;
            handleSwipe();
        });

        function handleSwipe() {
            const diffX = touchEndX - touchStartX;
            const diffY = touchEndY - touchStartY;
            const minSwipeDistance = 30;

            // Check if swipe is significant enough
            if (Math.abs(diffX) < minSwipeDistance && Math.abs(diffY) < minSwipeDistance) {
                return;
            }

            // Determine swipe direction
            const angle = Math.atan2(diffY, diffX) * 180 / Math.PI;
            
            // 8-directional swipe detection
            if (angle >= -22.5 && angle < 22.5) {
                changeDirection('right');
            } else if (angle >= 22.5 && angle < 67.5) {
                changeDirection('downright');
            } else if (angle >= 67.5 && angle < 112.5) {
                changeDirection('down');
            } else if (angle >= 112.5 && angle < 157.5) {
                changeDirection('downleft');
            } else if ((angle >= 157.5 && angle <= 180) || (angle >= -180 && angle < -157.5)) {
                changeDirection('left');
            } else if (angle >= -157.5 && angle < -112.5) {
                changeDirection('upleft');
            } else if (angle >= -112.5 && angle < -67.5) {
                changeDirection('up');
            } else if (angle >= -67.5 && angle < -22.5) {
                changeDirection('upright');
            }
        }

        // Update UI
        function updateUI() {
            if (myPlayerId && players[myPlayerId]) {
                myScoreElement.textContent = players[myPlayerId].score;
            }
            
            playerCountElement.textContent = Object.keys(players).length;
            
            // Update leaderboard
            const sortedPlayers = Object.values(players).sort((a, b) => b.score - a.score);
            playersListElement.innerHTML = sortedPlayers.map((player, index) => {
                const isMe = player.id === myPlayerId;
                const status = player.alive ? 
                    (player.powerUpActive ? 'üõ°Ô∏è Invincible' : '‚úÖ Alive') : 
                    'üíÄ Dead';
                return `
                    <div class="player-item" style="${isMe ? 'border: 2px solid yellow;' : ''}">
                        <div>
                            <span class="player-color" style="background: ${player.color.normal};"></span>
                            ${isMe ? 'üë§ You' : `Player ${index + 1}`} (${player.color.name})
                        </div>
                        <div>
                            <strong>${player.score}</strong> pts
                            <span class="player-status">${status}</span>
                        </div>
                    </div>
                `;
            }).join('');
        }

        // Draw game
        function drawGame() {
            // Clear canvas
            ctx.fillStyle = gridColor;
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // Draw grid
            ctx.strokeStyle = '#1a1a2e';
            ctx.lineWidth = 1;
            for (let i = 0; i <= tileCount; i++) {
                ctx.beginPath();
                ctx.moveTo(i * gridSize, 0);
                ctx.lineTo(i * gridSize, canvas.height);
                ctx.stroke();
                
                ctx.beginPath();
                ctx.moveTo(0, i * gridSize);
                ctx.lineTo(canvas.width, i * gridSize);
                ctx.stroke();
            }

            // Draw all snakes
            for (let playerId in players) {
                const player = players[playerId];
                if (!player.alive) continue;
                
                player.snake.forEach((segment, index) => {
                    const isMe = playerId === myPlayerId;
                    const isPoweredUp = player.powerUpActive;
                    const isBlink = blinkState[playerId];
                    
                    if (index === 0) {
                        // Snake head
                        if (isPoweredUp && isBlink) {
                            ctx.fillStyle = powerUpColor;
                        } else if (isPoweredUp) {
                            ctx.fillStyle = powerUpLightColor;
                        } else {
                            // Use skin data if available, otherwise fallback to color
                            ctx.fillStyle = player.skinData ? player.skinData.headColor : player.color.head;
                        }
                        
                        ctx.fillRect(
                            segment.x * gridSize + 1,
                            segment.y * gridSize + 1,
                            gridSize - 2,
                            gridSize - 2
                        );
                        
                        // Draw eyes
                        ctx.fillStyle = 'white';
                        const eyeSize = 4;
                        const dx = player.direction.dx;
                        const dy = player.direction.dy;
                        
                        let eye1X, eye1Y, eye2X, eye2Y;
                        
                        if (dx === 1 && dy === 0) {
                            eye1X = segment.x * gridSize + gridSize - 8;
                            eye1Y = segment.y * gridSize + 8;
                            eye2X = segment.x * gridSize + gridSize - 8;
                            eye2Y = segment.y * gridSize + gridSize - 12;
                        } else if (dx === -1 && dy === 0) {
                            eye1X = segment.x * gridSize + 4;
                            eye1Y = segment.y * gridSize + 8;
                            eye2X = segment.x * gridSize + 4;
                            eye2Y = segment.y * gridSize + gridSize - 12;
                        } else if (dy === 1 && dx === 0) {
                            eye1X = segment.x * gridSize + 8;
                            eye1Y = segment.y * gridSize + gridSize - 8;
                            eye2X = segment.x * gridSize + gridSize - 12;
                            eye2Y = segment.y * gridSize + gridSize - 8;
                        } else if (dy === -1 && dx === 0) {
                            eye1X = segment.x * gridSize + 8;
                            eye1Y = segment.y * gridSize + 4;
                            eye2X = segment.x * gridSize + gridSize - 12;
                            eye2Y = segment.y * gridSize + 4;
                        } else if (dx === 1 && dy === -1) {
                            eye1X = segment.x * gridSize + gridSize - 6;
                            eye1Y = segment.y * gridSize + 4;
                            eye2X = segment.x * gridSize + gridSize - 12;
                            eye2Y = segment.y * gridSize + 10;
                        } else if (dx === -1 && dy === -1) {
                            eye1X = segment.x * gridSize + 2;
                            eye1Y = segment.y * gridSize + 4;
                            eye2X = segment.x * gridSize + 8;
                            eye2Y = segment.y * gridSize + 10;
                        } else if (dx === 1 && dy === 1) {
                            eye1X = segment.x * gridSize + gridSize - 6;
                            eye1Y = segment.y * gridSize + gridSize - 8;
                            eye2X = segment.x * gridSize + gridSize - 12;
                            eye2Y = segment.y * gridSize + gridSize - 14;
                        } else if (dx === -1 && dy === 1) {
                            eye1X = segment.x * gridSize + 2;
                            eye1Y = segment.y * gridSize + gridSize - 8;
                            eye2X = segment.x * gridSize + 8;
                            eye2Y = segment.y * gridSize + gridSize - 14;
                        } else {
                            eye1X = segment.x * gridSize + gridSize - 8;
                            eye1Y = segment.y * gridSize + 8;
                            eye2X = segment.x * gridSize + gridSize - 8;
                            eye2Y = segment.y * gridSize + gridSize - 12;
                        }
                        
                        ctx.fillRect(eye1X, eye1Y, eyeSize, eyeSize);
                        ctx.fillRect(eye2X, eye2Y, eyeSize, eyeSize);
                        
                        // Add glow for my snake
                        if (isMe) {
                            ctx.strokeStyle = 'yellow';
                            ctx.lineWidth = 2;
                            ctx.strokeRect(
                                segment.x * gridSize + 1,
                                segment.y * gridSize + 1,
                                gridSize - 2,
                                gridSize - 2
                            );
                        }
                    } else {
                        // Snake body
                        if (isPoweredUp && isBlink) {
                            ctx.fillStyle = powerUpColor;
                        } else if (isPoweredUp) {
                            ctx.fillStyle = powerUpLightColor;
                        } else {
                            // Use skin data if available, otherwise fallback to color
                            ctx.fillStyle = player.skinData ? player.skinData.bodyColor : player.color.normal;
                        }
                        
                        ctx.fillRect(
                            segment.x * gridSize + 1,
                            segment.y * gridSize + 1,
                            gridSize - 2,
                            gridSize - 2
                        );
                    }
                });
            }

            // Draw regular food
            if (food) {
                ctx.fillStyle = foodColor;
                ctx.beginPath();
                ctx.arc(
                    food.x * gridSize + gridSize / 2,
                    food.y * gridSize + gridSize / 2,
                    gridSize / 2 - 2,
                    0,
                    Math.PI * 2
                );
                ctx.fill();
                
                ctx.fillStyle = 'rgba(255, 255, 255, 0.3)';
                ctx.beginPath();
                ctx.arc(
                    food.x * gridSize + gridSize / 2 - 2,
                    food.y * gridSize + gridSize / 2 - 2,
                    gridSize / 4,
                    0,
                    Math.PI * 2
                );
                ctx.fill();
            }

            // Draw special food (golden star)
            if (specialFood) {
                const centerX = specialFood.x * gridSize + gridSize / 2;
                const centerY = specialFood.y * gridSize + gridSize / 2;
                const outerRadius = gridSize / 2 - 2;
                const innerRadius = gridSize / 4;
                const spikes = 5;

                ctx.fillStyle = specialFoodColor;
                ctx.beginPath();
                
                for (let i = 0; i < spikes * 2; i++) {
                    const radius = i % 2 === 0 ? outerRadius : innerRadius;
                    const angle = (i * Math.PI) / spikes - Math.PI / 2;
                    const x = centerX + Math.cos(angle) * radius;
                    const y = centerY + Math.sin(angle) * radius;
                    
                    if (i === 0) {
                        ctx.moveTo(x, y);
                    } else {
                        ctx.lineTo(x, y);
                    }
                }
                
                ctx.closePath();
                ctx.fill();
                
                ctx.shadowColor = specialFoodColor;
                ctx.shadowBlur = 10;
                ctx.fill();
                ctx.shadowBlur = 0;
                
                ctx.fillStyle = 'rgba(255, 255, 255, 0.8)';
                ctx.beginPath();
                ctx.arc(centerX - 3, centerY - 3, 2, 0, Math.PI * 2);
                ctx.fill();
            }
        }

        // Skin Selection Functions
        function initializeSkinSelection() {
            // Load saved skin
            const savedSkin = localStorage.getItem('snakeSkin') || 'classic';
            currentSkin = savedSkin;
            selectedSkin = savedSkin;
            
            const skinGrid = document.getElementById('skinGrid');
            skinGrid.innerHTML = '';
            
            Object.keys(snakeSkins).forEach(skinKey => {
                const skin = snakeSkins[skinKey];
                const skinOption = document.createElement('div');
                skinOption.className = 'skin-option';
                if (skinKey === currentSkin) {
                    skinOption.classList.add('selected');
                }
                
                skinOption.innerHTML = `
                    <div class="skin-preview" id="preview-${skinKey}"></div>
                    <div class="skin-name">${skin.name}</div>
                    <div class="skin-description">${skin.description}</div>
                `;
                
                skinOption.onclick = () => selectSkin(skinKey);
                skinGrid.appendChild(skinOption);
                
                // Create preview
                createSkinPreview(skinKey, skin);
            });
        }

        function createSkinPreview(skinKey, skin) {
            const preview = document.getElementById(`preview-${skinKey}`);
            const canvas = document.createElement('canvas');
            canvas.width = 60;
            canvas.height = 60;
            const ctx = canvas.getContext('2d');
            
            // Draw snake segments
            const segmentSize = 12;
            const segments = [
                { x: 20, y: 20 },
                { x: 32, y: 20 },
                { x: 44, y: 20 }
            ];
            
            segments.forEach((segment, index) => {
                if (index === 0) {
                    // Head
                    ctx.fillStyle = skin.headColor;
                    ctx.fillRect(segment.x, segment.y, segmentSize, segmentSize);
                    
                    // Eyes
                    ctx.fillStyle = 'white';
                    ctx.fillRect(segment.x + 8, segment.y + 3, 3, 3);
                    ctx.fillRect(segment.x + 8, segment.y + 9, 3, 3);
                } else {
                    // Body
                    ctx.fillStyle = skin.bodyColor;
                    ctx.fillRect(segment.x, segment.y, segmentSize, segmentSize);
                }
            });
            
            preview.appendChild(canvas);
        }

        function selectSkin(skinKey) {
            selectedSkin = skinKey;
            
            // Update UI
            document.querySelectorAll('.skin-option').forEach(option => {
                option.classList.remove('selected');
            });
            event.target.closest('.skin-option').classList.add('selected');
            
            document.getElementById('applySkinBtn').disabled = false;
        }

        function applySkin() {
            currentSkin = selectedSkin;
            localStorage.setItem('snakeSkin', currentSkin);
            
            // Send skin change to server
            if (socket && myPlayerId) {
                socket.emit('changeSkin', { skin: currentSkin });
            }
            
            closeSkinSelection();
        }

        function openSkinSelection() {
            document.getElementById('skinSelection').classList.add('show');
        }

        function closeSkinSelection() {
            document.getElementById('skinSelection').classList.remove('show');
            selectedSkin = currentSkin; // Reset selection
            document.getElementById('applySkinBtn').disabled = true;
        }

        // Initialize skin selection on page load
        document.addEventListener('DOMContentLoaded', () => {
            initializeSkinSelection();
            
            // Add skin button event listener
            document.getElementById('skinBtn').addEventListener('click', openSkinSelection);
        });

        // Start drawing loop
        setInterval(drawGame, 50);
    </script>
</body>
</html>
